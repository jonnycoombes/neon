#region

using System;
using System.Collections.Generic;
using Serilog;
using JCS.Neon.Glow.Logging;

#endregion

namespace JCS.Neon.Glow.Cryptography
{
    /// <summary>
    ///     Class containing utilities for the generation of random numbers
    /// </summary>
    public static class Rng
    {
        /// <summary>
        /// Static logger
        /// </summary>
        private static ILogger _log = Log.ForContext(typeof(Rng));
        
        /// <summary>
        ///     Generates a sequence of random integers within a given bounded range.
        /// </summary>
        /// <param name="count">The number of integers to generate</param>
        /// <param name="min">The minimum value for any generated integers</param>
        /// <param name="max">The maximum value for any generated integers</param>
        /// <returns>An <see cref="IEnumerable{T}" /> which can be used to iterate over the generated integers</returns>
        public static IEnumerable<int> BoundedSequence(uint count, int min, int max)
        {
            LogHelpers.MethodCall(_log);
            var rng = new Random();
            while (count != 0)
            {
                yield return rng.Next(min, max);
                count--;
            }
        }

        /// <summary>
        ///     Generates a sequence of random doubles scaled by a supplied factor.
        /// </summary>
        /// <param name="count">The number of doubles to generate</param>
        /// <
        /// <param name="scale">Each generated double will be scaled by this value </param>
        /// <returns>An <see cref="IEnumerable{T}" /> which can be used to iterate over the generated doubles</returns>
        public static IEnumerable<double> BoundedSequence(uint count, double scale)
        {
            LogHelpers.MethodCall(_log);
            var rng = new Random();
            while (count != 0)
            {
                yield return rng.NextDouble() * scale;
                count--;
            }
        }

        /// <summary>
        ///     Generates a random sequence of byte values
        /// </summary>
        /// <param name="count">The number of generated bytes</param>
        /// <returns>An <see cref="IEnumerable{T}" /> which can be used to iterate over the generated bytes</returns>
        public static IEnumerable<byte> BoundedSequence(uint count)
        {
            LogHelpers.MethodCall(_log);
            var rng = new Random();
            while (count != 0)
            {
                var output = new byte[1];
                rng.NextBytes(output);
                yield return output[0];
                count--;
            }
        }
    }
}